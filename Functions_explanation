#################################
#         readline              #
#################################
#include <stdio.h>
#include <readline/readline.h>
#include <readline/history.h>

This is our get_next_line but with leaks and only read from STDIN.

Compile with -lreadline
char *readline (const char *prompt);
Reads a line from the terminal and returns it, using prompt as a prompt. We need to free it at the end.

Example:

	int main()
	{
		char* line = readline("BabyShell: ");
		if (line)
			printf("%s\n", line);
		else
			printf("Fail\n");

	}

################################################################################################
These 3 functions we need to recreate Ctr C
Compile with -lreadline -lhistory

	#################################   1
	#           rl_replace_line     #
	#################################
	void rl_replace_line(char* arg1, int arg2);
1 step:
	clean the current line



	#################################  2
	#           rl_on_new_line      #
	#################################
	int rl_on_new_line (void)
2 step:
	Inform readline about new line (jump to the next line)





	#################################  3
	#           rl_rediplay         #
	#################################
	void rl_redisplay (void)
3 step:
	Change what's displayed on the screen to reflect the current contents of rl_line_buffer.



Example:
	while (1)
                {
                        char* line = readline("BabyShell: ");
                        if (line[0] == '\0')
                                break ;
                        while (line[0] == 'C') #this will be Ctr C when Lyes show me how to use signals
                        {
                                rl_replace_line(line, 0);
                                rl_on_new_line();
                                line = readline("BabyShell: ");
                                rl_redisplay();
                                line = readline("BabyShell: ");
                        }
                        add_history(line);
                        printf("%s\n", line);
                        rl_clear_history();
                        free(line);
                }


###############################################################################################









#################################
#           add_history         #
#################################
Save a line in history so user can get at the line later. Avoid to use it for an empty line.

void add_history (const char *string)
Example:
	while (1)
                {
                        char* line = readline("BabyShell: ");
                        if (line[0] == '\0')
                                break ;
                        add_history(line);
                        printf("%s\n", line);
                }
While our program is working we can press ↑ and see previous commands. (if we want to recreate the behaviour of shell command 'history' we can make it manually after using add_history)


#################################
#     rl_clear_history          #
#################################
This function clears the entire command line history.
Has no parameters.
 






#################################
#        access                 #
#################################
#include <unistd.h>
int access(const char *pathname, int mode)
On success returns 0, error -1.
Access() checks if we can access the file. Useful to check if file exists or has permitions
Example: access("/home/minishell/test.c", F_OK);
F_OK  - mode that tests if file exists
R_OK  - mode that tests if file exists and has read permissions
W_OK  - mode that tests if file exists and has write permissions
X_OK  - mode that tests if file exists and has execute permissions



#################################
#           fork                #
#################################
#include <sys/types.h>
#include <unistd.h>

Creates a child process in our current program. We need it to execute commands in, because every execution exit a program. So we execute it in child program and still have access to the code in parent process.
pid_t fork(void);

Returns pid_t(it's the same as int, don't worry) -1 in case of a problem, 0 - in the child process and PID (process id) of a child is return in parent process (can be any number, like 24698)
Example:
	pid_t	i; 
	i = fork(); //creates a child process
	if (i == -1)
		Error
	if (i == 0)
		We are in child process
	We are in parent process



#################################
#           wait                #
#################################


#################################
#           waitpid             #
#################################


#################################
#           wait3               #
#################################

#################################
#           wait4               #
#################################


#################################
#           signal              #
#################################
#include <signal.h>

void (*signal(int sig, void (*func)(int)))(int);

Handle asyncronous event (event that happens outside of the program; ex : ctrl-C)
it takes as parameters a type of signal (ex : SIGINT) and a pointer to a function which handle the signal sent in parameter
This function can be custom made by the programmer or taken from a set list of predefined function
It is called signal handler

Return values :
	Success = the previous return value of the signal handler
	Fail = SIG_ERR which must be handled in the signal handler

Exemple :

void sig_handler(int singal)
{
	if (signal == SIGUSR1)
		printf("Success\n");
	else if (signal == SIG_ERR)
		printf("Failure\n");
}
int	main()
{
	signal(SIGUSR1, sig_handler);
	while (1)
		pause;
	return (0);
}

#################################
#        sigaction              #
#################################
#include <signal.h>

sigaction has the same uses as signal but is much more flexible and useful
it take the form of a structure as follows :
	struct sigaction
	{
		void		(*sa_handler)(int);
		void		(*sa_sigaction)(int, siginfo_t*, void*);
		sigset_t	sa_mask;
		int			sa_flags;
		void		(*sa_restorer)(void);
	};


#################################
#        sigemptyset            #
#################################

#################################
#           sigaddset           #
#################################


#################################
#           kill                #
#################################


#################################
#           getcwd              #
#################################


#################################
#           chdir               #
#################################


#################################
#           stat                #
#################################


#################################
#           lstat               #
#################################


#################################
#           fstat               #
#################################


#################################
#           unlink              #
#################################
#include <unistd.h>

Deletes file

int unlink(const char *path);
Success = 0
Fail = -1
Example:
	unlink("/home/minishell/deleteme.c");


#################################
#           execve              #
#################################
#include <unistd.h>

Fail = -1
Success - just executes command

Example:
	char **args = {"/bin/ls", "-l", NULL};
	
	execve(args[0], args, NULL);
	* Executes "ls" on Terminal, free all mallocs of current process, kill the process*




#################################
#           dup                 #
#################################
#include <unistd.h>
dup  — duplicate an open file descriptor

//I didn't use it in pipex, because dup2 was more useful

int dup(int fd);
Duplicates fd (for example fd = 3) and returns a new fd (next number that is free, for example new fd will be = 4 which is copy of fd 3)


#################################
#           dup2                #
#################################
#include <unistd.h>
dup2 — same as dup but fd copy is not random, we precise where duplicate

int	dup2(int fd1, int fd2);
Fail = -1
Success = new file descriptor

Example:
	int fd = open("outfile", O_RDWR);
	dup2(fd, STDOUT_FILENO); (stdouta_fileno - macro pour dire au compilateur stdout, terminal)
	
	We duplicated our outfile and put it at the place of STDOUT, so any printf after it will be not at Terminal but in outfile


#################################
#           pipe                #
#################################
#include <unistd.h>
int pipe(int fildes[2]);


Internal file pipe with 2 ends to access it
int pipes[2]; //declaration of 2 ends(2 files)
pipe(pipes); //calling the function pipe
pipe[0] - is used to read from file
pipe[1] - is used to write on file

cmd1 | cmd2

cmd1 is executed, the result is not on terminal, we don't see it because it is written on pipe[1]
cmd2 take the input not from STDIN (from terminal) but from pipe[0] and executes cmd2 on terminal

pipe is used like intermediary between 2 cmd






#################################
#           opendir             #
#################################
#include <sys/types.h>
#include <dirent.h>

  DIR *opendir(const char *name);

Success: return a pointer to the directory stream
Fail: NULL





#################################
#           readdir             #
#################################
 #include <dirent.h>

    struct dirent *readdir(DIR *dirp);

Success: returns a pointer to a dirent structure (no need to free)
Fail: NULL

Example:
	int main()      
	{
        	DIR             *directory = NULL;
	        struct dirent   *dir;

        	directory = opendir("TEST");

	        while((dir = readdir(directory)) != NULL)
        	{
                	printf("%s\n", dir->d_name); #print every file from directory TEST
	        }
	}



#################################
#           closedir            #
#################################
int closedir(DIR *dirp);

DEVINE :)






#################################
#           strerror            #
#################################
#include <string.h>

       char *strerror(int errnum);


Parameter 
Success: error message;
Fail: NULL;






#################################
#           perror              #
#################################



#################################
#           isatty              #
#################################



#################################
#           ttyname             #
#################################



#################################
#           ttyslot             #
#################################




#################################
#           ioctl               #
#################################


#################################
#           getenv              #
#################################



#################################
#           tcsetattr           #
#################################



#################################
#           tcgetattr           #
#################################



#################################
#           tgetent             #
#################################


#################################
#           tgetflag            #
#################################



#################################
#           tgetnum             #
#################################



#################################
#           tgetstr             #
#################################



#################################
#           tgoto               #
#################################



#################################
#           tputs               #
#################################
